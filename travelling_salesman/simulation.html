<!DOCTYPE html>
<html lang="en-US">

<head>
  <title>Travelling Salesman | Visualize It</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="keyword" content="travelling salesman, travelling salesman problem, tsp, interactive">
  <meta name="og:image" content="https://github.com/visualize-it/visualize-it.github.io/raw/main/images_webp/travelling_salesman.webp">

  <!-- Materialize -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
  <script src="basic.js" defer></script>
  <script src="renderers.js" defer></script>
  <script src="travelling_salesman.js" defer></script>
  <script src="user_input.js" defer></script>
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

  <!-- CSS -->
  <link rel="stylesheet" href="../style.css" />
</head>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-M95CKRP8HB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { window.dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'G-M95CKRP8HB');
</script>

<body>
  <nav class="nav-extended" style="background:black; margin-top: 0mm">
    <div class="nav-wrapper">
      <h1 id="main-heading">Visualize It</h1>
    </div>
    <div class="nav-content">
      <ul class="tabs tabs-transparent tabs-fixed-width">
        <li class="tab"><a href="../index.html">Home</a></li>
        <li class="tab"><a href="../about.html">About</a></li>
      </ul>
    </div>
  </nav>
  <div class="text">
    <h2>Travelling Salesman</h2>
    <center>
      <p>
        Given a list of cities and the distances between each pair of cities, what is the shortest possible route that
        visits each city exactly once and returns to the origin city?
      </p>
    </center>
    <br>
    <div class="container">
      <div class="row">
        <div class="col s12 l8">
          <canvas id="canvas"></canvas>
          <center>
            <p id="solution"></p>
          </center>
        </div>
        <div class="col s12 l4">
          <center>
            <button class="btn purple darken-4" onclick="solve()">Solve</button>
            <button class="btn purple darken-4" onclick="clearCoords()">Clear</button>
            <br> <br>
            <button id="add-button" class="btn purple darken-4" onclick="addRandom(1)">Add Random</button>
            <button id="remove-button" class="btn purple darken-4" onclick="removeLast(1)">Remove Last</button>
            <br> <br>
            <p>
              Touch the canvas in order to add a point. You cannot add points when solution is being calculated.
            </p>
          </center>
        </div>
        <center>
          <center>

          </center>
        </center>
        <div class="col s6">

        </div>
        <div class="col s6">

        </div>
        <center>

        </center>
      </div>
    </div>

    <br>
    <hr>

    <h3>Trivia</h3>
    <p>This problem is classified as NP-hard since it's time complexity is \( \mathcal{O} (n!) \) (Along with a space
      complexity of \( \mathcal{O} (n) \)). The only assured way of obtaining the shortest path is via brute-force
      search, which involves looking at all possible paths and keeping track of the shortest ones encountered. However,
      the number of possible paths grows factorially with number of nodes (which is asymptotically faster than even
      exponential growth). Hence, there are several ways through which we can get 'shorter' but not the 'shortest' path:

    <ol>
      <li>
        <b>Nearest Neighbour:</b> <br>
        Start at a particular node. Travel to the nearest node. Repeat. This algorithm is very simple to implement.
      </li>
      <li>
        <b>Greedy Heuristic:</b> <br>
        Form the initial path with shorter edges, and connect them.
      </li>
      <li>
        <b>Simulated Annealing:</b> <br>
        Inspired by the way crystals cool, this method tries to converge to a local minima while implementing a cooling
        schedule. In every step, two nodes from the path are switched, and the resulting path is accepted or rejected
        using Metropolis algorithm (please find intricate details <a href="../ising_model/simulation.html">here</a>).
      </li>
      <li>
        <b>Genetic Algorithm:</b> <br>
        A poplation of entities whose genes comprise of paths, and whose fitness is based on how short the paths are.
        Fitter entities have greater chance of their genes making it into the offspring. Also uses mutation (to explore
        prospectively better avenues) and recombination (to combine the best of two genes).
      </li>
      <li>
        <b>Ant Colony Optimization:</b> <br>
        Initially, a population of ants randomly traverse the graph. By gauging the shortness of each edge, they leave
        more pheromones along that edge. In the next iteration, at every node, the ants choose the edge on a
        probabilistic manner, weighted by pheromone strength. Both, genetic algorithm and ant colony optimization are
        called metaheuristic methods because they solve the problem at hand by working at a higher level, instead of
        directly tackling the problem.
      </li>
      <li>
        <b>Christofides' Algorithm</b> <br>
        Considered the gold standard of solving the Travelling Salesman Problem, this algorithm utilizes insights from
        an easily solvable problem in graph theory (constructing a minimal spanning tree from a given graph) and
        manipulates it to arrive at (on average) comparatively shorter paths.
      </li>
    </ol>
    </p>

    <hr>
    <br>

    <b>Note:</b>
    <ol>
      <li>I will try to make simulations of the optimized algorithms above, if time permits.</li>
      <li>When there are 8+ points, then an initial lag is expected before the solving process starts</li>
      <li>With 10 points, an average time of 49 minutes was required to find the solution to the route</li>
      <li>Simulation may lag on lower-end computers and phones</li>
    </ol>

    <br>
    <hr>

    <p class="center-align">Developed by ChanRT | Fork me at <a href="https://www.github.com/chanrt">GitHub</a></p>
  </div>
</body>

</html>